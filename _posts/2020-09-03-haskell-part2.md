---
layout: post
title: haskell-part2
tags: [haskell]
---

### Functors, Applicative Functors and Monoids

#### Functors redux

å­¦ä¸¤ä¸ªæ–°çš„ functor å¼•ç”¨ï¼Œ`IO` å’Œ`(->) r`

ä¹‹å‰æœ‰è¯´è¿‡ï¼Œå¦‚æœæŸä¸ªå€¼çš„ç±»å‹æ˜¯IO String, é‚£æ„å‘³ç€ä»–æ˜¯ä¸€ä¸ªIO actionï¼Œæ‰§è¡Œä»–ä¼šå¾—åˆ°ä¸€ä¸ªstringï¼Œå¯ä»¥ç”¨`<-`ç¬¦å·æ¥ç»‘å®šç»“æœåˆ°ä¸€ä¸ªåå­—ä¸Šã€‚æˆ‘ä»¬æåˆ°è¿‡ï¼ŒI / O actionå°±åƒæ˜¯ä¸€åªæœ‰å°è„šä¸«çš„ç›’å­ï¼Œå¯ä»¥å‘å¤–ç§»åŠ¨å¹¶ä¸ºæˆ‘ä»¬ä»å¤–éƒ¨è·å–ä¸€äº›å€¼ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥æ‹¿åˆ°çš„å€¼ï¼Œä½†æ˜¯æ£€æŸ¥å®Œåè¦æŠŠä»–åŒ…è£…å›IOã€‚

<!-- more -->

çœ‹çœ‹IOæ˜¯æ€æ ·çš„ä¸€ä¸ªFunctorå®ä¾‹ï¼š

```haskell
instance Functor IO where  
    fmap f action = do  
        result <- action  
        return (f result)  
```

resultç»‘å®šäº†actionçš„å€¼åï¼Œå†ä½œä¸ºå‚æ•°ä¼ é€’ç»™fæ¥æ‰§è¡Œï¼Œç„¶åreturnå›å»ï¼Œä¹‹å‰æåˆ°è¿‡returnç›¸å½“äºåå‘çš„`<-`æ“ä½œï¼Œä¸€ä¸ªæ˜¯ä»ç›’å­é‡Œæ‹¿å‡ºä¸œè¥¿æ¥ï¼Œä¸€ä¸ªæ˜¯æŠŠä¸œè¥¿å¡å›ç›’å­é‡Œã€‚å› æ­¤ï¼Œfæ‰§è¡Œåä¼šè¿”å›ä¸€ä¸ªIO actionã€‚

```haskell
main = do line <- getLine   
          let line' = reverse line  
          putStrLn $ "You said " ++ line' ++ " backwards!"  
          putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"  
```

ä¸Šé¢è¿™ä¸ªä»£ç å¾ˆå¥½ç†è§£ï¼Œæ¥å—ç”¨æˆ·è¾“å…¥ï¼Œå°†å…¶reverseåè¿”å›ã€‚é‚£æ¥çœ‹çœ‹å¦‚ä½•ç”¨fmapé‡å†™ï¼š

```haskell
main = do line <- fmap reverse getLine  
          putStrLn $ "You said " ++ line ++ " backwards!"  
          putStrLn $ "Yes, you really said" ++ line ++ " backwards!"  
```

å¦ä¸€ä¸ªä¹‹å‰ä¸€ç›´åœ¨ç”¨ï¼Œä½†æ˜¯ä¸çŸ¥é“ä»–å…¶å®æ˜¯ä¸€ä¸ªfunctorå®ä¾‹çš„functoræ˜¯`(->) r`ï¼Œè¿™å•¥ç©æ„ï¼Ÿ`r -> a`å’Œ`(->) r a`çš„æ„æ€æ˜¯ä¸€æ ·çš„ï¼Œçœ‹å‡ºæ¥äº†å—ï¼Ÿ`->`å°±åƒä¸€ä¸ª`+`ä¸€æ ·ï¼Œ`(+) 2 3`å’Œ`2 + 3`æ˜¯ä¸€æ ·çš„ã€‚`(->)`ä¸åŒçš„æ˜¯ï¼Œä»–æ˜¯ä¸€ä¸ªæ¥å—ä¸¤ä¸ªç±»å‹å‚æ•°çš„ç±»å‹æ„é€ å­ï¼Œå°±åƒ`Either`ä¸€æ ·ã€‚ä½†æ˜¯è®°å¾—ï¼Œæˆä¸ºä¸€ä¸ªFunctorå®ä¾‹ï¼Œå¾—æ˜¯æ¥å—**ä¸€ä¸ª**ç±»å‹å‚æ•°çš„ï¼Œå› æ­¤`(->)`ä¸èƒ½æˆä¸ºFunctorå®ä¾‹ï¼Œéœ€è¦partiallyå`(->) r`ã€‚

```haskell
instance Functor ((->) r) where  
    fmap f g = (\x -> f (g x))  
```

å†æ¥çœ‹çœ‹fmapé•¿å•¥æ ·ï¼š

```haskell
fmap :: (a -> b) -> f a -> f b
```

æ¥ä¸‹æ¥ç”¨` (->) r `æ¥æ›¿æ¢ä¸Šé¢æ‰€æœ‰çš„fï¼Œå¾—åˆ°ï¼š

```haskell
fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
```

ç„¶åè¦åšçš„å°±æ˜¯æ¢æˆä¸­ç¼€è¡¨è¾¾å¼ï¼š

```haskell
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```

å°†ä¸€ä¸ªå‡½æ•°æ˜ å°„æˆå¦ä¸€ä¸ªå‡½æ•°ï¼Œç„¶åè§‚å¯Ÿè¿™ä¸‰ä¸ªå‡½æ•°çš„è¾“å…¥è¾“å‡ºï¼Œä¸€ä¸ªå‡½æ•°çš„è¾“å…¥æ˜¯å¦ä¸€ä¸ªå‡½æ•°çš„è¾“å‡ºï¼Œç„¶åè¾“å‡ºçš„å‡½æ•°çš„æ˜¯ä¸€ä¸ªå‡½æ•°çš„è¾“å…¥ï¼Œå¦ä¸€ä¸ªå‡½æ•°çš„è¾“å‡ºï¼Œå‘ç°è¿™ç©æ„æœ‰ç‚¹åƒä»€ä¹ˆäº†éº½ï¼Ÿå¯¹ï¼Œå‡½æ•°ç»„åˆï¼Œpipeã€‚fmapå°±æ˜¯ä¸€ä¸ªå‡½æ•°ç»„åˆè€Œå·²ã€‚å¦ä¸€ä¸ªå†™æ³•æ˜¯ï¼š

```haskell
instance Functor ((->) r) where  
    fmap = (.)  
```

```
ghci> (*3) `fmap` (+100) $ 1  
303  
ghci> (*3) . (+100) $ 1  
303 

```

fmapçš„å®Œæ•´å®šä¹‰æ˜¯ï¼š`fmap :: Functor f => (a -> b) -> f a -> f b`ã€‚åœ¨ä¸Šæ–‡ä¸­æåˆ°çš„æ—¶å€™å°‘å†™äº†Functor fè¿™ä¸ªé™åˆ¶æ¡ä»¶ã€‚åœ¨æœ€å¼€å§‹å­¦ä¹ curried functionçš„æ—¶å€™ï¼Œæˆ‘ä»¬è¯´æ‰€æœ‰çš„haskellå‡½æ•°å®é™…éƒ½åªæ¥å—ä¸€ä¸ªå‚æ•°ã€‚`a->b->c`ä¹Ÿå¯ä»¥å†™æˆ`a->(b->c)`ï¼Œè¿™æ ·å°±æ˜¾å¾—curryæ›´æ˜æ˜¾äº†ã€‚

åŒæ ·çš„é“ç†ï¼Œå¦‚æœå†™æˆ` fmap :: (a -> b) -> (f a -> f b) `ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸æŠŠä»–çœ‹ä½œæ˜¯æ¥å—ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªfunctorç„¶åè¿”å›ä¸€ä¸ªfunctorï¼Œè€Œæ˜¯æ¥å—ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ–°å‡½æ•°ã€‚ä»`(a -> b) `åˆ°` (f a -> f b) `ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªç§°ä¹‹ä¸º**lifting a function**ã€‚

ä½ å¯ä»¥è®¤ä¸ºfmapæ˜¯ä¸€ä¸ª**æ¥å—ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªfunctorï¼Œé€šè¿‡è¿™ä¸ªå‡½æ•°æ¥æ˜ å°„è¿™ä¸ªfunctorå¾—åˆ°ä¸€ä¸ªæ–°çš„functor**çš„å‡½æ•°ï¼Œä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯æ¥å—ä¸€ä¸ªå‡½æ•°ï¼Œç„¶åliftingè¿™ä¸ªå‡½æ•°ï¼Œä½¿å¾—å¯ä»¥åœ¨functorä¸Šæ“ä½œè¿è¡Œã€‚è¿™ä¸¤ç§çœ‹æ³•éƒ½å¯¹ã€‚

æ¥ä¸‹æ¥çœ‹çœ‹functor laws

- å¦‚æœç”¨å‡½æ•°idæ¥æ˜ å°„ä¸€ä¸ªfunctorï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°çš„functorè¦è·ŸåŸæ¥çš„functoræ˜¯ä¸€æ ·çš„

  æ¯”å¦‚æ¥çœ‹ä¸‹Maybeçš„fmapå®ç°ï¼š

  ```haskell
  instance Functor Maybe where  
      fmap f (Just x) = Just (f x)  
      fmap f Nothing = Nothing  
  
  ```

  è¿™é‡Œæˆ‘ä»¬æƒ³è±¡ä¸‹fæ˜¯idï¼Œé‚£ä¹ˆ`fmap id (Just x)`çš„ç»“æœå°±æ˜¯`Just (id x)`ï¼Œç„¶åå› ä¸ºidå°±æ˜¯è¿”å›ä¸¢ç»™ä»–çš„å‚æ•°ï¼Œå› æ­¤æœ€ç»ˆç»“æœå°±ç­‰äº`Just x`ã€‚è¿™å°±æ˜¯æ‰€è°“çš„ç”¨idæ¥æ˜ å°„ä¸€ä¸ªfunctorå°†å¾—åˆ°è¿™ä¸ªfunctoræœ¬èº«çš„æ„æ€ã€‚

- ç¬¬äºŒæ¡lawè¯´ï¼Œç»„åˆä¸¤ä¸ªå‡½æ•°ï¼Œç„¶åæ˜ å°„è¿™ä¸ªç»„åˆåçš„å‡½æ•°å¾—åˆ°çš„ç»“æœï¼Œåº”è¯¥è¦å’Œä»¥æ­¤æ˜ å°„ä¸¤ä¸ªå‡½æ•°çš„ç»“æœä¸€æ ·ã€‚` fmap (f . g) F = fmap f (fmap g F) `

  è¿˜æ‹¿Maybeæ¥ä¸¾ä¾‹ï¼š` fmap (f . g) (Just x) `====` Just ((f . g) x) `===` Just (f (g x)) `ï¼Œ

  ` fmap f (fmap g (Just x)) `===`fmap f (Just (g x))`===`Just (f (g x))`

å¦‚æœä¸€ä¸ªç±»å‹éµå®ˆä¸Šè¿°ä¸¤æ¡è§„åˆ™ï¼Œé‚£ä¹ˆåœ¨æ˜ å°„ä»–çš„æ—¶å€™å°±å¯ä»¥ç›¸ä¿¡è¿™ä¸ªç±»å‹å…·æœ‰å…¶ä»–functoréƒ½æœ‰çš„ä¸€äº›åŸºæœ¬è¡Œä¸ºã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰Functorçš„å®ä¾‹éƒ½æ»¡è¶³è¿™ä¸¤æ¡ï¼Œä½ å®Œå…¨å¯ä»¥é€ ä¸€ä¸ªç±»å‹ï¼Œè®©ä»–å®ç°fmapï¼Œèƒ½ç”¨å¹¶ä¸ä¼šæŠ¥é”™ï¼Œä½†æ˜¯ä¸æ»¡è¶³ä¸Šè¿°è§„åˆ™ã€‚ä½†æ˜¯æ ‡å‡†åº“é‡Œçš„éƒ½æ˜¯æ»¡è¶³çš„ï¼Œå¯ä»¥æ”¾å¿ƒç”¨ã€‚

ä¹Ÿå› æ­¤ï¼Œåœ¨æ„é€ ä¸€ä¸ªFunctorå®ä¾‹çš„ç±»å‹çš„æ—¶å€™ï¼Œè¦èŠ±ç‚¹æ—¶é—´æ£€æŸ¥ä¸‹æ˜¯å¦æ»¡è¶³ä¸Šè¿°è§„åˆ™ï¼Œåšå¾—å¤šäº†ï¼Œå°±èƒ½å¾ˆç›´è§‚çš„åˆ†è¾¨å‡ºè¿™ä¸ªç±»å‹æ˜¯å¦æ»¡è¶³æ¡ä»¶ã€‚

#### Applicative functors

è¿™ä¸€èŠ‚è®²åº”ç”¨å‡½å­ï¼Œä»–æ˜¯ä¸€ç§å¢å¼ºçš„å‡½å­ï¼Œåœ¨Control.Applicativeæ¨¡å—ä¸­ï¼Œè¡¨ç¤ºä¸ºApplicative ç±»å‹ç±»ã€‚

å½“æˆ‘ä»¬åœ¨å‡½å­ä¸Šæ˜ å°„å‡½æ•°æ—¶ï¼Œé€šå¸¸è¿™ä¸ªæ˜ å°„å‡½æ•°æ˜¯æ¥å—ä¸€ä¸ªå‚æ•°çš„ï¼Œé‚£ä¹ˆå¦‚æœé‡åˆ°æ¥å—ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°å‘¢ï¼Ÿæ¯”å¦‚`*`æ¥å—ä¸¤ä¸ªå‚æ•°ã€‚å½“æ‰§è¡Œ`fmap (*) (Just 3)`çš„æ—¶å€™ï¼Œä¼šå¾—åˆ°ä»€ä¹ˆå‘¢ï¼Ÿä¸Šæ–‡æåˆ°äº†Maybeæ˜¯å¦‚ä½•å®ç°Functorå®ä¾‹çš„ï¼Œå¯ä»¥æ¨å‡ºï¼Œä¸Šè¿°ä»£ç çš„ç»“æœä¼šæ˜¯`Just (* 3)`ï¼Œæœ‰è¶£ï¼Œæˆ‘ä»¬åœ¨Justé‡Œæ”¾è¿›äº†ä¸ªå‡½æ•°ã€‚

```
*Main> :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])

```

é‚£å¯ä»¥å¦‚ä½•ä½¿ç”¨å‘¢ï¼Ÿ

```haskell
 let a = fmap (*) [1,2,3,4]
 fmap (\f -> f 9) a -- [9,18,27,36]

```

aè¢«æ˜ å°„å®Œåæˆäº†ä¸€ä¸ªpartialå‡½æ•°æ•°ç»„ï¼Œç„¶åå†æ˜ å°„è¿™ä¸ªæ•°ç»„ï¼Œå‡½å­ï¼ˆè¿™é‡Œçš„aï¼‰å†…éƒ¨çš„ä»»ä½•å†…å®¹éƒ½å°†åšä¸ºå‚æ•°ä¼ é€’åˆ°æ˜ å°„å‡½æ•°ä¸Šï¼ˆè¿™é‡Œçš„`\f -> f 9`ï¼‰ã€‚å¾ˆå¥½ç†è§£ã€‚

é‚£å¦‚ä½•æœ‰ä¸€ä¸ªå‡½å­`Just (3 *)`ï¼Œå¦ä¸€ä¸ªå‡½å­`Just 5`ï¼Œå¸Œæœ›æŠŠç¬¬ä¸€ä¸ªå‡½å­ä¸­çš„å‡½æ•°æ‹¿å‡ºæ¥ï¼Œç„¶åæ˜ å°„åˆ°ç¬¬äºŒä¸ªå‡½å­ä¸Šï¼Œå°±åšä¸åˆ°äº†ã€‚ä¹‹å‰éƒ½æ˜¯åœ¨mapä¸€ä¸ªæ™®é€šçš„å‡½æ•°(`\f -> f 9 `)ï¼Œè€Œä¸æ˜¯è¿™ç§è¢«è£¹åœ¨å‡½å­ä¸­çš„å‡½æ•°ã€‚è¿™ä¸ªå°±éœ€è¦ä»‹ç»Applicative ç±»å‹ç±»äº†ã€‚

```haskell
class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b  

```

ç¬¬ä¸€è¡Œå‘Šè¯‰æˆ‘ä»¬ï¼Œè¦æƒ³æˆä¸ºApplicativeçš„ä¸€éƒ¨åˆ†ï¼Œä½ é¦–å…ˆå¾—æ˜¯ä¸€ä¸ªFunctorï¼Œè¿™ä¹Ÿè¯´æ˜å¦‚æœä¸€ä¸ªç±»å‹æ„é€ å­æ˜¯Applicativeçš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆä»–åŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªFunctorï¼Œå¯ä»¥ä½¿ç”¨fmapã€‚

ç¬¬äºŒè¡Œï¼Œä¸€ä¸ªå«åšpureçš„æ–¹æ³•ï¼Œè¿™é‡Œçš„fä»£è¡¨ä¸€ä¸ªåº”ç”¨å‡½å­å®ä¾‹ã€‚æ¥æ”¶ä»»æ„ç±»å‹ï¼Œè¿”å›ä¸€ä¸ªå¡äº†ä¸€ä¸ªå€¼åœ¨é‡Œé¢çš„åº”ç”¨å‡½å­ã€‚

ç¬¬ä¸‰è¡Œï¼Œè¿™ç©æ„å¾ˆåƒ`fmap :: (a -> b) -> f a -> f b`ï¼Œè¿™å°±æ˜¯ä¼ è¯´ä¸­çš„å¢å¼ºç‰ˆfmapï¼ŒåŸç‰ˆfmapæ˜¯æ¥å—ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªå‡½å­ï¼Œç„¶åæŠŠè¿™ä¸ªå‡½æ•°åº”ç”¨åˆ°è¿™ä¸ªå‡½å­é‡Œé¢ã€‚è€Œ **<\*>** æ˜¯æ¥å—ä¸€ä¸ªé‡Œé¢å¡äº†ä¸€ä¸ªå‡½æ•°çš„å‡½å­ï¼Œä»¥åŠå¦ä¸€ä¸ªå‡½å­ï¼Œè¿™é‡Œä»–åšçš„å°±æ˜¯æŠŠå‡½å­é‡Œçš„å‡½æ•°æå–å‡ºæ¥ï¼Œç„¶åä½œç”¨åˆ°ç¬¬äºŒä¸ªå‡½å­ä¸Šã€‚

```haskell
instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something  

```

æœ‰äº†è¿™ä¸ªï¼Œä¸Šé¢æåˆ°é‚£ä¸ªé—®é¢˜å°±å¯ä»¥è§£å†³äº†ï¼Œä»å‡½å­ä¸­çš„å‡½æ•°æ‹¿å‡ºæ¥å»æ˜ å°„å¦ä¸€ä¸ªå‡½å­ï¼Œ

```
*Main> Just (+3) <*> Just 9
Just 12
*Main> pure (+3) <*> Just 10
Just 13
*Main> Nothing <*> Just "woot"
Nothing
*Main> pure (+) <*> Just 3 <*> Just 5
Just 8

```

`pure f <*> x`è¦ç­‰äº`fmap f x`ï¼Œè¿™æ˜¯ applicative laws ä¸­çš„ä¸€æ¡ã€‚`pure f <*> x <*> y <*>`å¯ä»¥å†™æˆ`fmap f x <*> y <*> `ã€‚Control.Applicativeå¯¼å‡ºäº†ä¸€ä¸ªå«åš`<$>`çš„å‡½æ•°ï¼Œå…¶å®åªæ˜¯æŠŠfmapå½“ä½œä¸€ä¸ªä¸­ç¼€æ“ä½œç¬¦ã€‚è¿™æ ·å°±èƒ½ç»§ç»­å†™æˆ`f <$> x <*> y <*> z`

```haskell
(<$>) :: (Functor f) => (a -> b) -> f a -> f b  
f <$> x = fmap f x  

```

```
*Main> (++) <$> Just "johntra" <*> Just "volta"
Just "johntravolta"

```

`(++) <$> Just "johntra"`çš„ç»“æœæ˜¯`Just ("johntra"++)`ï¼Œä¸€ä¸ªè£…äº†å‡½æ•°çš„å‡½å­ï¼Œæ¥ä¸‹æ¥å°±å¾ˆå¥½ç†è§£äº†ã€‚

æ•°ç»„ä¹Ÿæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼Œ

```haskell
instance Applicative [] where  
    pure x = [x]  
    fs <*> xs = [f x | f <- fs, x <- xs] 

```

pureè·Ÿä¹‹å‰ä¸€æ ·ï¼Œæ¥å—ä¸€ä¸ªå€¼ï¼Œä¸¢åˆ°é»˜è®¤contextä¸­ï¼Œä¸‹é¢è¿™è¡Œï¼Œè¿™ç§å½¢å¼å« list comprehension ï¼Œåœ¨æœ€å¼€å§‹çš„æ—¶å€™å°±è¯´åˆ°äº†ï¼Œæ„æ€æ˜¯æ‹¿fsä¸­çš„ä¸œè¥¿å»æ˜ å°„xsä¸­çš„ä¸œè¥¿ã€‚

```haskell
*Main> [(*0),(+100),(^2)] <*> [1,2,3]
[0,0,0,101,102,103,1,4,9]
*Main> [(+),(*)] <*> [1,2] <*> [3,4]
[4,5,5,6,3,4,6,8]
*Main>  (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]

```

è«åå…¶å¦™ï¼Œçœ‹ç€è¿˜æŒºå¥½ç©ã€‚list comprehensionçš„å½¢å¼æ¢æˆ<*>é£æ ¼ï¼š

```haskell
*Main> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
*Main> (*) <$> [2,5,10] <*> [8,10,11]
[16,20,22,40,50,55,80,100,110]

```

è¿˜æœ‰ä¸€ä¸ªåº”ç”¨å‡½å­æ˜¯ä¹‹å‰å­¦è¿‡çš„IO

```haskell
instance Applicative IO where  
    pure = return  
    a <*> b = do  
        f <- a  
        x <- b  
        return (f x)  

```

è¿™ä¸ªpureæˆ‘æœ‰ç‚¹ä¸æ˜¯å¾ˆç†è§£ï¼Œä¹¦ä¸Šè¯´ï¼šç”±äºpureå°±æ˜¯å°†å€¼æ”¾åœ¨æœ€å°çš„ä¸Šä¸‹æ–‡ï¼ˆminimal contextï¼‰ä¸­ï¼Œè€Œè¯¥ä¸Šä¸‹æ–‡ä»ç„¶ä¿ç•™å…¶ç»“æœã€‚å•¥å«minimal contextå‘¢ï¼Œæœ‰å¾…ç†è§£ã€‚

ç„¶åä¸‹é¢çš„å†…å®¹åå€’å¾ˆå¥½ç†è§£ï¼Œå¦‚æœ`<*>`ç”¨äºIOï¼Œé‚£ä¹ˆç±»å‹å°±æ˜¯`(<*>) :: IO (a -> b) -> IO a -> IO b`ï¼Œå¦‚ä½•è¿ä½œçš„ä¹Ÿä¸€ç›®äº†ç„¶ã€‚

```haskell
myAction :: IO String  
myAction = do  
    a <- getLine  
    b <- getLine  
    return $ a ++ b

```

è¿™ä¸ªä»£ç å¾ˆç®€å•æ¥å—ä¸¤æ¬¡è¾“å…¥ï¼Œç„¶åæŠŠä»–ä»¬è¿æ¥èµ·æ¥è¾“å‡ºã€‚åªæ˜¯çœ‹åˆ°`$`æˆ‘ä¸€æ—¶æœ‰ç‚¹æ‡µé€¼ï¼Œç¾å…ƒç¬¦å·è™½ç„¶å·²ç»å­¦è¿‡ï¼Œä½†æ˜¯å†™åœ¨returnè¿™é‡Œæœ‰ç‚¹æ²¡ååº”è¿‡æ¥ï¼Œå…¶å®æ˜¯è¯´æ˜è¿™æ¡è¯­å¥å…ˆæŠŠç¾å…ƒç¬¦å·å³è¾¹çš„æ‰§è¡Œå®Œäº†å†è¿”å›ï¼Œå¦‚æœä¸å†™è¿™ä¸ªç¬¦å·å°±è¦ç»™`a ++ b`åŠ ä¸Šæ‹¬å·ã€‚

ä¸Šé¢çš„ä»£ç ä¹Ÿç”¨ applicative é£æ ¼æ¥å†™ï¼š

```haskell
myAction :: IO String  
myAction = (++) <$> getLine <*> getLine

```

`(++) <$> getLine <*> getLine`çš„ç»“æœæ˜¯ä¸€ä¸ªIO Actionï¼Œè¿™å°±ä»¥ä¸ºè¿™ä¹Ÿå¯ä»¥è¿™æ ·å†™

```haskell
main = do  
    a <- (++) <$> getLine <*> getLine  
    putStrLn $ "The two lines concatenated turn out to be: " ++ a  

```

`(->) r`ä¹Ÿæ˜¯åº”ç”¨å‡½å­

```haskell
instance Applicative ((->) r) where  
    pure x = (\_ -> x)  
    f <*> g = \x -> f x (g x) 

```

æœ€åè¿™è¡Œä¸æ˜¯å¾ˆç†è§£ã€‚ã€‚ã€‚ã€‚å½“`<*>`è¿æ¥ä¸¤ä¸ªå‡½æ•°å‡½å­çš„æ—¶å€™ï¼Œç»“æœæ˜¯ä¸€ä¸ªå‡½æ•°ï¼š

```haskell
*Main> (+) <$> (+10) <*> (+5) $ 9
33

```

å‚æ•°ä¸¢è¿›æ¯ä¸ªå‡½æ•°ï¼Œç„¶åæŠŠç»“æœä¸¢åˆ°æœ€å‰é¢çš„å‡½æ•°ï¼ˆ+ï¼‰é‡Œã€‚

äº‹å®ä¸Šæœ‰å¾ˆå¤šæ–¹æ³•è®©æ•°ç»„æˆä¸ºåº”ç”¨å‡½å­ï¼Œä¸€ç§æ–¹å¼å°±æ˜¯ä¸Šé¢æåˆ°çš„ç›´æ¥ä½¿ç”¨`<*>`è¿æ¥ã€‚

```haskell
*Main> [(+3),(*2)] <*> [1,2]
[4,5,2,4]

```

ç¬¬ä¸€ä¸ªæ•°ç»„ä¸­çš„æ¯ä¸ªå‡½æ•°éƒ½ä¼šä½œç”¨äºåé¢æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚é‚£æˆ‘ä»¬æœ‰å¯èƒ½éœ€è¦çš„æ˜¯ï¼Œé‚£ç§ä¸€ä¸€å¯¹åº”çš„é‚£ç§å‘¢ï¼Ÿç¬¬ä¸€ä¸ªå‡½æ•°å¯¹åº”ç¬¬ä¸€ä¸ªå…ƒç´ è¿™ç§ã€‚è¿™å°±æœ‰äº†ZipList

```haskell
instance Applicative ZipList where  
        pure x = ZipList (repeat x)  
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)  

```

è¿™é‡Œçš„pureä¹Ÿå€¼å¾—å›å‘³ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªæ— é™æ•°ç»„ã€‚è¦ä½¿ç”¨è¿™ç©æ„è¦å¯¼å…¥`:m Control.Applicative`

```haskell
Prelude > :m Control.Applicative
Prelude Control.Applicative> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
[101,102,103]
Prelude Control.Applicative> getZipList $ (,,) <$> ZipList "dog""
[('d','c','r'),('o','a','a'),('g','t','t')]

```

è¿™é‡Œæœ‰ä¸ªæ–°ç©æ„`(,,)`ï¼Œä»”ç»†ä¸€çœ‹è¿˜æŒºå¯çˆ±ğŸ¤ï¼Œè¿™ç©æ„å°±ç›¸å½“äº`\x y z -> (x,y,z)`ï¼ŒåŒæ ·`(,)`å°±ç›¸å½“äº`\x y -> (x,y)`ã€‚haskellçœŸæ˜¯ç®€æ´çš„å¯æ€•â€¦â€¦

#### The newtype keyword

è·Ÿdataä¸€æ ·éƒ½èƒ½åˆ›å»ºç±»å‹ï¼Œå¹¶ä¸”newtypeæ›´å¿«ã€‚ä¸åŒçš„æ˜¯è¿™ä¸ªé™å®šäº†åªèƒ½æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°å¹¶ä¸”åªæœ‰ä¸€ä¸ªå­—æ®µã€‚ä¸ºä»€ä¹ˆéœ€è¦è¿™ç©æ„å‘¢ï¼Ÿæˆ‘å¤§æ¦‚è¿™æ ·ç†è§£çš„ï¼Œåƒæ•°ç»„ä»–æœ¬æ¥å°±å®ç°äº†Functoräº†ï¼Œé‚£ä¹ˆåœ¨fmapä»–çš„æ—¶å€™è¡Œä¸ºå°±å®šäº†ï¼Œä½†æ˜¯ä½ æƒ³è¦åœ¨fmapçš„æ—¶å€™å®ç°åˆ«çš„è¡Œä¸ºï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦å®ç°ä¸€ä¸ªæ–°çš„Functorå¼•ç”¨ï¼Œä½†æ˜¯ä¸€ç§ç±»å‹åªèƒ½å®ç°ä¸€æ¬¡ä¸æ˜¯éº½ï¼Œé‚£å°±ç”¨é‡æ–°æ„é€ ä¸€ä¸ªæ–°ç±»å‹ï¼Œé‡Œé¢å°±åŒ…ä¸€ä¸‹æœ¬æ¥è¦ç”¨çš„é‚£ä¸ªç±»å‹å°±å¥½äº†ï¼Œè¿™å°±æœ‰äº†newtypeã€‚

æ¯”å¦‚ï¼Œæƒ³tupleåœ¨fmapçš„æ—¶å€™æ˜¯é»˜è®¤æ“ä½œåé¢é‚£ä¸ªæ•°çš„ï¼Œé‚£å¦‚æœæƒ³è¦æ“ä½œå‰é¢é‚£ä¸ªæ•°å’‹åŠå‘¢ï¼Ÿå°±æ„é€ ä¸€ä¸ªæ–°ç±»

```
Prelude> fmap (+3) (1, 3)
(1,6)

```

```haskell
newtype Pair b a = Pair { getPair :: (a, b)}

instance Functor (Pair c) where
  fmap f (Pair (x, y)) = Pair (f x, y)

```

```
*Main> getPair $ fmap (+3) $ Pair (1, 3)
(4,3)

```

è¿™æ®µä»£ç å¾ˆå°‘ï¼Œçœ‹ç€ä¹Ÿç®€å•ï¼Œä½†æ˜¯è¿˜æ˜¯è®©æˆ‘ç¨å¾®æƒ³äº†ä¸€ä¼šå„¿ã€‚æœ‰å‡ ä¸ªé—®é¢˜ï¼Œé¦–å…ˆä¸ºä»€ä¹ˆPairçš„ç±»å‹å‚æ•°æ˜¯`b a`è€Œä¸æ˜¯`a b`ï¼Œç„¶åcåˆæ˜¯å¹²å˜›çš„ï¼Œç„¶ågetPairæ€ä¹ˆç†è§£ã€‚

é¦–å…ˆè¿™ä¸ªcå…¶å®å¾ˆè¿·æƒ‘ï¼Œå¦‚æœæ¢æˆbå°±å¾ˆå¥½ç†è§£äº†ã€‚è¿™å°±æ˜¯å› ä¸ºå®ç°Functoræ—¶æ¥å—çš„è¿™ä¸ªå‡½æ•°åªæœ‰èƒ½æœ‰ä¸€ä¸ªå‚æ•°ï¼Œå› æ­¤åšäº†ä¸€ä¸ªpatialå‡½æ•°è€Œå·²ã€‚è€Œå¦‚æœPairçš„ç±»å‹å‚æ•°è°ƒæ¢é¡ºåºçš„è¯ï¼Œæ˜¯ä¼šæŠ¥é”™çš„ï¼Œå› ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå›æƒ³ä¸‹fmapçš„ç±»å‹ï¼š

```haskell
fmap :: Functor f => (a -> b) -> f a -> f b

```

fmapçš„få®é™…ä¸Šå°±æ˜¯Pair cï¼Œç›¸å½“äºï¼š

```haskell
fmap :: (a -> b) -> Pair c a -> Pair c b  

```

ç„¶åå¦‚æœPairçš„ç±»å‹å‚æ•°è°ƒæ¢è¿‡æ¥çš„è¯ï¼Œé‚£ä¹ˆè¢«partialçš„å°±æ˜¯aï¼Œä¹Ÿå°±æ˜¯Pairé‡Œé¢çš„tupleçš„ç¬¬ä¸€ä¸ªå€¼çš„ç±»å‹ï¼Œè€Œç­‰å¾…æ¥æ”¶ï¼Œæˆ–è€…è¯´ç­‰å¾…å¤„ç†çš„ç±»å‹å˜æˆäº†bã€‚è¿™æ ·`Pair (f x, y)`å°±æœ‰é—®é¢˜ï¼Œ**fçš„å‚æ•°ä¸€å®šé‚£ä¸ªè¦ç­‰å¾…å¤„ç†çš„ç±»å‹**ï¼Œè™½ç„¶è¿™é‡Œç†è§£æ„Ÿè§‰æœ‰ç‚¹å¥‡æ€ªï¼Œå…ˆæš‚æ—¶è¿™æ ·æƒ³å§ã€‚

è¿˜æœ‰ä¸€ä¸ªè¿·æƒ‘çš„åœ°æ–¹æ˜¯ï¼Œä¸‹é¢çš„`Pair c`å’Œ`Pair (x, y)`ï¼Œå‰è€…æ˜¯ç±»å‹æ„é€ å­ï¼Œè€Œåè€…æ˜¯å€¼æ„é€ å­ã€‚

```haskell
instance Functor (Pair c) where
  fmap f (Pair (x, y)) = Pair (f x, y)

```

ç„¶åæ˜¯getPairï¼Œè¿™ç©æ„ä¸äº†è§£çš„è¯å¯ä»¥å†çœ‹çœ‹dataæ„é€ ç±»å‹é‚£å—å†…å®¹

```haskell
getPair :: Pair b a -> (a, b)

```

**On newtype laziness**

newtypeæ›´å¿«ï¼Œè€Œä¸”å”¯ä¸€èƒ½å¹²çš„äº‹æƒ…å°±æ˜¯æŠŠä¸€ä¸ªå·²ç»å­˜åœ¨çš„ç±»å‹è½¬æ¢æˆå¦å¤–çš„ç±»å‹ã€‚å½“ç„¶ä¹Ÿæ˜¯lazyçš„ã€‚

å½“è¾“å…¥undefinedçš„æ—¶å€™ä¼šæŠ¥é”™ï¼š

```
ghci> undefined  
*** Exception: Prelude.undefined  

```

è€Œä¸‹é¢è¿™æ ·å´ä¸ä¼šæŠ¥é”™ï¼Œå› ä¸ºlazyçš„åŸå› ï¼Œhsä¸ä¼šçœŸçš„å»è®¡ç®—åé¢çš„å†…å®¹ã€‚

```
ghci> head [3,4,5,undefined,2,undefined]  
3

```

ç°åœ¨è€ƒè™‘ä¸‹é¢çš„ä»£ç ï¼š

```haskell
data CoolBool = CoolBool { getCoolBool :: Bool }
helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello" 

```

CoolBoolç”¨dataæ„é€ ï¼Œå¹¶ä¸”åªæœ‰ä¸€ä¸ªå€¼æ„é€ å­ï¼Œåªæœ‰ä¸€ä¸ªç±»å‹ä¸ºBoolçš„å­—æ®µã€‚

```
*Main> helloMe undefined
"*** Exception: Prelude.undefined

```

ä¸ºä»€ä¹ˆä¼šæŠ¥é”™å‘¢ï¼Ÿå› ä¸ºdataæ„é€ çš„ç±»å‹ä¼šæœ‰å¾ˆå¤šå€¼æ„é€ å­ï¼ˆè™½ç„¶è¿™é‡Œåªæœ‰ä¸€ä¸ªï¼‰ï¼Œæ‰€ä»¥hsä¸ºäº†å»æ£€æµ‹ç»™åˆ°çš„å‚æ•°ç±»å‹èƒ½ç”¨ä¸‹é¢çš„é‚£ä¸ªæ¨¡å¼åŒ¹é…ï¼Œä¼šå»è®¡ç®—ç»™åˆ°çš„è¿™ä¸ªå€¼ï¼Œæ‰€ä»¥è®¡ç®—åˆ°äº†undefinedï¼Œè‡ªç„¶ä¼šæŠ¥é”™ã€‚

æ¢æˆnewtypeå®šä¹‰ï¼š

```haskell
newtype CoolBool = CoolBool { getCoolBool :: Bool }

```

å…¶ä»–éƒ½ä¸å˜ï¼Œå°±æ”¹äº†ä¸ªå…³é”®å­—newtypeï¼Œç„¶å`helloMe undefined`å°±ä¸ä¼šæŠ¥é”™äº†ã€‚å› ä¸ºhsçŸ¥é“newtypeå®šä¹‰çš„ç±»å‹è‚¯å®šåªæœ‰ä¸€ä¸ªå€¼æ„é€ å­ï¼Œæ‰€ä»¥ä»–ä¸éœ€è¦å»æå‰å¥½è¦åŒ¹é…é‚£ä¸ªæ¨¡å¼ï¼Œç›´æ¥æŠŠå€¼å¾€é‡Œæ‰”å°±å¥½äº†ã€‚

è¿™å‘Šè¯‰æˆ‘ä»¬ï¼Œè™½ç„¶newtypeå’Œdataå¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯æœ‰äº›å¤„ç†æœºåˆ¶å…¶å®æ˜¯ä¸ä¸€æ ·çš„ã€‚

#### Monoids

å½“åˆ›å»ºä¸€ä¸ªç±»å‹çš„æ—¶å€™ï¼Œè¦è€ƒè™‘ä»–æ”¯æŒä»€ä¹ˆè¡Œä¸ºï¼Œè¦è¡¨ç°æˆä»€ä¹ˆæ ·ï¼Œè¦å®ç°å“ªä¸ªç±»å‹ç±»ã€‚

å‡½æ•°`*`æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œå®Œæˆä¹˜æ³•æ“ä½œï¼Œå¹¶ä¸”`1 * x == x *1`ï¼Œç±»ä¼¼è¿™ç§çš„è¿˜æœ‰`++`ï¼Œä¹Ÿæ˜¯æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œä¹ŸåŒæ ·æœ‰ç±»ä¼¼çš„ç‰¹ç‚¹ï¼Œæ¯”å¦‚`[1,2,3] ++ [] == [] ++ [1,2,3]`ã€‚ä»–ä»¬è¿˜æœ‰ä¸€ä¸ªå…±åŒç‚¹å°±ï¼Œæ»¡è¶³åƒæ˜¯äº¤æ¢å¾‹çš„é‚£ç§è§„å¾‹ã€‚

```
ghci> (3 * 2) * (8 * 5)  
240  
ghci> 3 * (2 * (8 * 5))  
240  
ghci> "la" ++ ("di" ++ "da")  
"ladida"  
ghci> ("la" ++ "di") ++ "da"  
"ladida"

```

æ³¨æ„åˆ°äº†è¿™äº›ç‰¹ç‚¹ï¼Œç„¶åå°±æœ‰äº†monoidsï¼ä¸Šé¢çš„1ä¹‹äº`*`ï¼Œ[]ä¹‹äº`++`ï¼Œè¢«ç§°ä½œ**identity value**

```haskell
class Monoid m where  
    mempty :: m  
    mappend :: m -> m -> m  
    mconcat :: [m] -> m  
    mconcat = foldr mappend mempty 
```

è¿™ä¸ªç±»å‹ç±»å®šä¹‰åœ¨`import Data.Monoid`ä¸­ï¼Œmæ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œè€Œä¸æ˜¯åƒMaybeé‚£æ ·çš„ç±»æ„é€ å­ï¼Œå› ä¸ºmå¹¶æ²¡æœ‰æ¥å—ä»»ä½•ç±»å‹å‚æ•°ã€‚

ç¬¬ä¸€ä¸ªå‡½æ•°memptyï¼Œå¹¶ä¸æ˜¯ä¸€ä¸ªçœŸçš„å‡½æ•°ï¼Œå› ä¸ºä»–ä¸æ¥å—å‚æ•°ï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªå¤šæ€å¸¸é‡ï¼Œè¡¨ç¤ºç‰¹å®šmonoidsçš„identity valueã€‚

ç„¶åmappendï¼Œä¸è¦æƒ³å¤ªå¤šï¼Œå°±æ˜¯æ¥å—è¿ä¸ªå‚æ•°ï¼Œè¿”å›ç¬¬ä¸‰ä¸ªè€Œå·²ã€‚

ç„¶åmconcatï¼Œæ¥å—ä¸€ä¸ªmonoidsæ•°ç»„ï¼Œç„¶åreduceæˆå•ä¸ªå€¼ã€‚ä¸‹é¢æœ‰ç»™äº†ä¸€ä¸ªé»˜è®¤çš„å®ç°ã€‚åœ¨å®ç°ä¸€ä¸ªmonoidå®ä¾‹çš„æ—¶å€™ï¼Œé€šå¸¸åªè¦å®ç°memptyå’Œmappendå°±å¤Ÿäº†ï¼Œå› ä¸ºé»˜è®¤çš„mconcaté€šå¸¸æ¥æ˜¯å¤Ÿç”¨çš„ã€‚

åœ¨è®¨è®ºmonoidç‰¹å®šå®ä¾‹ä¹‹å‰ï¼Œå…ˆçœ‹ä¸‹ä»–çš„åŸºæœ¬è§„åˆ™ã€‚

- mempty \`mappend\` x = x
- x \`mappend\` mempty = x
- (x \`mappend\` y) \`mappend\` z = x \`mappend\` (y \`mappend\` z)

**æ•°ç»„çš„å®ç°**

```haskell
instance Monoid [a] where  
    mempty = []  
    mappend = (++)  
```

ä»£ç å¾ˆå¥½æ‡‚ï¼Œè¦æ³¨æ„çš„æ˜¯è¿™é‡Œå†™çš„æ˜¯[a]ï¼Œè€Œä¸æ˜¯[]ï¼Œå› ä¸ºè¿™é‡Œéœ€è¦çš„æ˜¯ä¸€ä¸ª**å…·ä½“ç±»å‹**ã€‚

```
ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]
ghci> mconcat [[1,2],[3,6],[9]]  
[1,2,3,6,9]  
ghci> mempty :: [a]  
[]
```

#### Using monoids to fold data structures

æ•°ç»„å¯ä»¥ç”¨æ¥foldï¼Œä½†æ˜¯æ•°ç»„å…¶å®ä¸æ˜¯å”¯ä¸€å¯ä»¥ç”¨æ¥foldçš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å‡ ä¹å¯ä»¥å¯¹ä»»ä½•æ•°æ®ç»“æ„å®šä¹‰foldã€‚å› æ­¤å°±æœ‰äº†**Foldable**ç±»å‹ç±»ï¼Œå°±åƒFunctorå¯ä»¥ç”¨æ¥mapï¼ŒFoldableå¯ä»¥ç”¨æ¥foldã€‚

```
Prelude> :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
```

è¿™ä¸ªç±»å‹è¿˜ç®—å¥½ç†è§£å§ï¼ŒæŠŠ`t a`é‡Œçš„aæ‹¿å‡ºæ¥å’Œbä¸€èµ·ä¸¢åˆ°å‡½æ•°`a -> b -> b`ä¸­ï¼Œæƒ³æƒ³reduceï¼Œbå…¶å®å°±ç›¸å½“äºåˆå§‹å€¼å§

```
ghci> foldr (*) 1 [1,2,3]  
6 
```

ä¸€ç§æŠŠä¸€ä¸ªç±»å‹æ„é€ å­åšæˆFoldableçš„æ–¹å¼æ˜¯ç›´æ¥å®ç°foldrï¼Œä½†æ˜¯å¦ä¸€ç§æ›´ç®€å•çš„æ–¹å¼æ˜¯å®ç°foldMapå‡½æ•°ï¼ŒfoldMapä¹Ÿæ˜¯Foldableç±»å‹ç±»çš„ä¸€éƒ¨åˆ†

```
Prelude> :t foldMap
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
```

### A Fistful of Monads

å›é¡¾ä¸€ä¸‹ï¼Œfunctorå¯ä»¥æ¥å—ä¸€ä¸ªå‡½æ•°æ¥mapä¸€ä¸ªå‡½å­é‡Œçš„å€¼ï¼Œç„¶åapplicative functorï¼Œæ¥å—çš„ä¸€ä¸ªé‡Œé¢æ”¾äº†å‡½æ•°çš„å‡½å­ï¼Œå¹¶å°†é‚£ä¸ªå‡½æ•°æ‹¿å‡ºæ¥ä½œä¸ºmapçš„å‡½æ•°ï¼Œå¾—åˆ°çš„ç»“æœæ˜¯ä¿ç•™äº†ä¸Šä¸‹æ–‡çš„ï¼Œä¸Šä¸‹æ–‡æŒ‡çš„æ˜¯ï¼Œæ¯”å¦‚`'a'`åªæ˜¯ä¸€ä¸ªæ™®é€šçš„å­—ç¬¦ä¸²ï¼Œä½†æ˜¯`Maybe 'a'`å°±å«å¸¦äº†ä¸Šä¸‹æ–‡äº†ã€‚è¿™ç« å¼€å§‹è®²Monadsï¼Œä¸€ç§applicative functorçš„å¢å¼ºç‰ˆï¼Œå°±å¥½æ¯”åº”ç”¨å‡½å­æ˜¯å‡½å­çš„å¢å¼ºç‰ˆä¸€æ ·ã€‚

#### Getting our feet wet with Maybe

è€ƒè™‘ä¸‹åº”ç”¨å‡½å­æ˜¯å¦‚ä½•åšåˆ°æœ€åç»“æœä¿ç•™äº†ä¸Šä¸‹æ–‡å‘¢ï¼Ÿéœ€è¦ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼šæ¥å—ä¸€ä¸ªå¥‡æ€ªçš„å€¼ï¼Œæ¥å—ä¸€ä¸ªæ¥å—æ­£å¸¸å€¼å¹¶è¿”å›ä¸€ä¸ªå¥‡æ€ªå€¼çš„å‡½æ•°ï¼Œç„¶åè¿”å›ä¸€ä¸ªå¥‡æ€ªå€¼ã€‚è¿˜æ‹¿Maybeæ¥è¯´ï¼š

```haskell
applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b  
applyMaybe Nothing f  = Nothing  
applyMaybe (Just x) f = f x  
```

```
*Main> Just 3 `applyMaybe` \x -> Just (x+1)
Just 4
```

#### The Monad type class

Monadä¹Ÿæœ‰ä»–è‡ªå·±çš„ç±»å‹ç±»

```haskell
class Monad m where  
    return :: a -> m a  
  
    (>>=) :: m a -> (a -> m b) -> m b  
  
    (>>) :: m a -> m b -> m b  
    x >> y = x >>= \_ -> y  
  
    fail :: String -> m a  
    fail msg = error msg  
```

ç¬¬ä¸€è¡Œï¼Œè¦çŸ¥é“çš„æ—¶å€™ï¼Œmé¦–å…ˆå¾—æ˜¯åº”ç”¨å‡½å­ï¼Œä½†æ˜¯è¿™é‡Œæ²¡æœ‰å†™`class (Applicative m) = > Monad m where`ï¼Œä»–è¿™é‡Œä¸ªç†ç”±æˆ‘æ²¡å¤ªæ‡‚ï¼Œè¯´æ˜¯Haskellåœ¨åˆ¶ä½œçš„æ—¶å€™å¹¶æ²¡æœ‰æƒ³åˆ°ï¼Ÿä½†æ˜¯ç»“è®ºæ˜¯è¦è®°ä½æ¯ä¸€ä¸ªMonadéƒ½æ˜¯åº”ç”¨å‡½å­ï¼Œå³ä½¿è¿™é‡Œçš„å£°æ˜é‡Œæ²¡æœ‰å†™ã€‚

ç¬¬äºŒè¡Œï¼Œreturnçš„ä½œç”¨è·Ÿåº”ç”¨å‡½å­ç±»å‹ç±»çš„pureä¸€æ ·ï¼Œåªæ˜¯æ¢äº†ä¸ªåå­—ï¼Œä½œç”¨éƒ½æ˜¯æ¥å—ä¸€ä¸ªå€¼ï¼Œè¿”å›ä¸€ä¸ªä¿å­˜äº†è¯¥å€¼çš„æœ€å°ä¸Šä¸‹æ–‡ï¼Œè¿˜è®°å¾—IOçš„æ—¶å€™ç”¨åˆ°çš„returnå—ï¼Ÿé‚£æ—¶å€™è¯´çš„æ˜¯returnå°±æ˜¯ç»‘å®šçš„åå‘æ“ä½œï¼Œç»‘å®šæ˜¯å°†ä¸€ä¸ªå€¼ä»ç›’å­é‡Œå–å‡ºæ¥ï¼Œè€Œreturnæ˜¯å°†å€¼å¡å›å»ã€‚

å€¼å¾—å¼ºè°ƒçš„æ˜¯ï¼šhsçš„returnè·Ÿå…¶ä»–å¤§å¤šæ•°è¯­è¨€çš„returnæ˜¯ä¸ä¸€æ ·çš„ï¼Œä»–å¹¶ä¸ä¼šç»“æŸå‡½æ•°çš„æ‰§è¡Œï¼Œè€Œåªæ˜¯æ¥å—ä¸€ä¸ªå€¼ï¼Œå°†å…¶ä¸¢è¿›æœ€å°ä¸Šä¸‹æ–‡ä¸­ã€‚

ç¬¬ä¸‰è¡Œï¼Œç»‘å®šï¼Œæˆ–è€…è¯´å‡½æ•°çš„åº”ç”¨ã€‚

ç¬¬å››è¡Œï¼Œç°åœ¨ä¸ä¼šè®²å¤ªå¤šè¿™ä¸ªï¼Œä»–æœ‰é»˜è®¤å®ç°ï¼Œå¹¶ä¸”æˆ‘ä»¬åœ¨åˆ¶ä½œmonadå¼•ç”¨çš„æ—¶å€™å‡ ä¹ä¸ä¼šå®ç°ä»–

æ¥ä¸‹æ¥çš„failï¼Œæš‚æ—¶ä¸éœ€è¦è€ƒè™‘å¤ªå¤šã€‚

çœ‹çœ‹Maybeæ˜¯å¦‚ä½•æ˜¯å®ç°Monadçš„ï¼š

```haskell
instance Monad Maybe where  
    return x = Just x  
    Nothing >>= f = Nothing  
    Just x >>= f  = f x  
    fail _ = Nothing  
```

`>>=`å’Œä¹‹å‰çš„applyMaybeä¸€æ ·ã€‚

```
*Main> Just 9 >>= \x -> return (x*10)
Just 90
```

è¿™é‡Œè¦è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªlamdaå‡½æ•°ï¼Œä¹‹å‰çš„applyMaybeæ˜¯å†™æ­»äº†è¿”å›Justçš„ï¼Œè€Œè¿™é‡Œæ˜¯ç”¨çš„returnã€‚ï¼ˆè¿™å°±æ˜¯returnçš„å¦™ç”¨å—ï¼Ÿ

#### do notation

è¿˜è®°å¾—doå—ï¼Ÿåœ¨è®²IOçš„æ—¶å€™å‡ºç°è¿‡ï¼Œä½œç”¨æ˜¯å°†å¤šä¸ªIO actionèåˆæˆä¸€ä¸ªï¼Œå…¶å®doä¸åªæ˜¯èƒ½ä½œç”¨ä¸IOï¼Œä»–èƒ½ä½œç”¨ä¸ä»»ä½•monadã€‚

```haskell
Just 3 >>= (\x -> Just (show x ++ "!"))
Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y))
let x = 3; y = "!" in show x ++ y
```

è¿™ä¸‰è¡Œçš„è¾“å‡ºéƒ½æ˜¯ä¸€æ ·çš„ï¼š`3!`ï¼Œä¸åŒçš„æ˜¯å‰ä¸¤ä¸ªçš„å€¼æ˜¯ monadic ï¼Œæœ‰æœ‰å¯èƒ½å¤±è´¥çš„ä¸Šä¸‹æ–‡ã€‚

```haskell
foo :: Maybe String  
foo = Just 3   >>= (\x -> 
      Just "!" >>= (\y -> 
      Just (show x ++ y))) 
```

```haskell
foo :: Maybe String  
foo = do  
    x <- Just 3  
    y <- Just "!"  
    Just (show x ++ y)  
```

doçš„å†™æ³•è®©äººçœ‹èµ·æ¥åƒæ˜¯æ‹¥æœ‰äº†å¯ä»¥ä¸´æ—¶æå–å‡ºMaybeçš„å€¼è€Œæ— éœ€æ£€æŸ¥è¿™ä¸ªå€¼æ˜¯Justè¿˜æ˜¯Nothingçš„èƒ½åŠ›ï¼Œå¦‚æœä¸­é—´å‡ºç°äº†Nothingï¼Œé‚£æœ€åçš„ç»“æœä¹Ÿæ˜¯Nothingã€‚æ¯”å¦‚ï¼š

```haskell
foo = do  
    x <- Just 3  
    y <- Just "!"
    z <- Nothing
    Just (show x ++ y) 
```

doçœ‹èµ·æ¥å¾ˆåƒæ˜¯å‘½ä»¤å¼ç¼–ç¨‹ï¼Œä½†æ˜¯å…¶å®doä¸­çš„æ¯ä¸€è¡Œéƒ½æ˜¯è¿ç»­çš„ï¼Œä¾èµ–ç€å‰ä¸€è¡Œçš„ã€‚ä»ä¸Šé¢çš„ä»£ç ä¹Ÿèƒ½çœ‹å‡ºæ¥ï¼Œzå¹¶æ²¡æœ‰è¢«ç”¨åˆ°ï¼Œä½†æ˜¯æœ€åçš„ç»“æœè¿˜æ˜¯Nothingã€‚

å½“åœ¨doä¸­ä¸å†™`<-`æ—¶å°±å¥½åƒåœ¨å°†`>>`æ”¾åœ¨ è¦å¿½ç•¥å…¶ç»“æœçš„monadic value åé¢ï¼Œè¿™æ¯”`_ <- Nothing`è¦ç®€æ´ï¼Œæ•ˆæœæ˜¯åŒæ ·çš„ã€‚

```haskell
foo = do  
    x <- Just 3  
    y <- Just "!"
    Nothing
    Just (show x ++ y) 
```

åœ¨doä¸­ç»‘å®šå€¼çš„æ—¶å€™å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼Œå°±åƒletè¡¨è¾¾å¼å’Œå‡½æ•°å‚æ•°é‚£æ ·ã€‚

```haskell
justH :: Maybe Char  
justH = do  
    (x:xs) <- Just "hello"  
    return x 
```

ä¸€ä¸ªæ¨¡å¼åŒ¹é…å¤±è´¥äº†ä¼šå»åŒ¹é…ä¸‹ä¸€ä¸ªï¼Œå¦‚æœæ‰€æœ‰çš„åŒ¹é…éƒ½å¤±è´¥äº†ï¼Œåœ¨letä¸­ä¼šç«‹åˆ»æŠ¥é”™ï¼Œè€Œå¦‚æœåœ¨doä¸­ï¼Œå‡½æ•°failä¼šè¢«è°ƒç”¨ã€‚

```haskell
fail :: (Monad m) => String -> m a  
fail msg = error msg  
```

é»˜è®¤æƒ…å†µä¸‹ä¼šä½¿æˆ‘ä»¬çš„ç¨‹åºå´©æºƒæ‰ï¼Œä½†æ˜¯monadsæ˜¯åŒ…æ‹¬äº†ä¼šå¤±è´¥çš„ä¸Šä¸‹æ–‡çš„ï¼Œæ¯”å¦‚Maybeï¼Œæ‰€ä»¥é€šå¸¸ä¼šå®ç°è‡ªå·±çš„failå‡½æ•°ã€‚åƒMaybeçš„ï¼š

```haskell
fail _ = Nothing 
```

ä»–å¿½ç•¥äº†é”™è¯¯æ¶ˆæ¯ï¼Œå¹¶ç›´æ¥è¿”å›ä¸€ä¸ªNothingï¼Œ

```haskell
wopwop :: Maybe Char  
wopwop = do  
    (x:xs) <- Just ""  
    return x
```

#### The list monad

è¿™ä¸€èŠ‚ï¼Œæˆ‘ä»¬å°†ç ”ç©¶å¦‚ä½•ä½¿ç”¨åˆ—è¡¨çš„monadå½¢å¼ä»¥æ¸…æ™°æ˜“è¯»çš„æ–¹å¼å°†ä¸ç¡®å®šæ€§ï¼ˆ non-determinism ï¼‰å¼•å…¥æˆ‘ä»¬çš„ä»£ç ä¸­ã€‚

```haskell
instance Monad [] where  
    return x = [x]  
    xs >>= f = concat (map f xs)  
    fail _ = [] 
```

```
Prelude> [3,4,5] >>= \x -> [x,-x]
[3,-3,4,-4,5,-5]
Prelude> [] >>= \x -> ["bad","mad","rad"]
[]
```

åœ¨å›é¡¾ä¸€ä¸‹`>>=`ï¼Œæ¥å—ä¸€ä¸ªæœ‰ä¸Šä¸‹æ–‡çš„å€¼ä»¥åŠä¸€ä¸ªæ¥å—ä¸€ä¸ªæ™®é€šå€¼è¿”å›ä¸€ä¸ªå¸¦ä¸Šä¸‹æ–‡çš„å€¼çš„å‡½æ•°ã€‚ä¸Šé¢çš„ç»“æœå¾ˆå®¹æ˜“ç†è§£ï¼Œåªæ˜¯å°†lamdaå‡½æ•°mapåˆ°æ¯ä¸ªå…ƒç´ ï¼Œç„¶åå†ç”¨concatæ‰“å¹³è€Œå·²ã€‚éç¡®å®šæ€§è¿˜åŒ…æ‹¬å¯¹å¤±è´¥çš„æ”¯æŒã€‚`[]`å°±è·ŸNothingä¸€æ ·ï¼Œè¡¨ç¤ºæ²¡æœ‰ç»“æœã€‚

æŠŠä»–ä»¬ä¸²èµ·æ¥ä½¿ç”¨ï¼š

```
Prelude> [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
```

```haskell
listOfTuples :: [(Int,Char)]  
listOfTuples = do  
    n <- [1,2]  
    ch <- ['a','b']  
    return (n,ch)
```

doå½¢å¼çš„nå’Œchéƒ½æ˜¯ä¼šå–åˆ°æ•°ç»„é‡Œçš„æ¯ä¸ªå€¼ã€‚ List comprehensionså½¢å¼ï¼š

```
*Main>  [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
```

å®é™…ä¸Š List comprehensionsåªæ˜¯æŠŠListå½“ä½œmonadä½¿ç”¨çš„è¯­æ³•ç³–ï¼Œæœ€ç»ˆè¿˜æ˜¯ç¿»è¯‘åˆ°doä¸­ï¼Œç”¨`>>=`æ¥è®¡ç®—ã€‚è¿™ç©æ„è¿˜èƒ½åœ¨åé¢æ¥ä¸ªè¿‡æ»¤æ“ä½œï¼š

```
*Main> [ x | x <- [1..50], '7' `elem` show x ]
[7,17,27,37,47]
```

è¦çŸ¥é“æ˜¯æ€ä¹ˆå®ç°çš„ï¼Œéœ€è¦çœ‹ä¸€ä¸‹`MonadPlus`è¿™ä¸ªç±»å‹ç±»ï¼Œ

```haskell
class Monad m => MonadPlus m where  
    mzero :: m a  
    mplus :: m a -> m a -> m a
```

mzeroå¯¹åº”äºMonoidç±»å‹ç±»çš„memptyï¼Œ mplus å¯¹åº”äºmappendï¼ŒListsæ—¢æ˜¯monoidåˆæ˜¯monad

```haskell
instance MonadPlus [] where  
    mzero = []
    mplus = (++)
```

```haskell
guard :: (MonadPlus m) => Bool -> m ()  
guard True = return ()  
guard False = mzero
```

guardå‡½æ•°æ¥å—ä¸€ä¸ªboolå€¼ï¼Œå¦‚æœæ˜¯Trueå°±å°†`()`ä¸¢åˆ°æœ€å°ä¸Šä¸‹æ–‡ä¸­ï¼Œå¦åˆ™å°±å¾—åˆ°ä¸€ä¸ªå¤±è´¥çš„ç»“æœã€‚

```
ghci> guard (5 > 2) :: Maybe ()  
Just ()  
ghci> guard (1 > 2) :: Maybe ()  
Nothing  
ghci> guard (5 > 2) :: [()]  
[()]  
ghci> guard (1 > 2) :: [()]  
[] 
```

```
*Main> [1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)
[7,17,27,37,47]
```

ä¸Šé¢è¿™æ ·ç”¨çš„ç»“æœå°±è·ŸList Comprehensionä¸€æ ·äº†ã€‚guardè¿™ç©æ„æ˜¯å¦‚ä½•åšåˆ°çš„å‘¢ï¼Ÿå…ˆçœ‹çœ‹ä»–è¿æ¥`>>`æ—¶ï¼š

`>>`çš„å®šä¹‰æ˜¯ä¸‹é¢è¿™æ ·çš„ï¼Œæœ€ç»ˆä¹Ÿæ˜¯`>>=`æ¥è®¡ç®—äº†ï¼Œåªæ˜¯ä»–å¿½ç•¥è¾“å…¥ï¼Œç›´æ¥è¾“å‡ºæŸç»“æœï¼Œä½†æ˜¯å› ä¸ºæ˜¯ç”¨`>>=`æ¥è®¡ç®—çš„ï¼Œæ‰€ä»¥éšå«äº†ä¸€æ¡å°±æ˜¯ï¼Œå¦‚æœè¾“å…¥æ˜¯ä¸€ä¸ªå¤±è´¥çš„å€¼ï¼Œé‚£ä¹ˆæœ€ç»ˆçš„ç»“æœæ˜¯å¤±è´¥çš„ï¼å› ä¸ºfailureè¿æ¥`>>=`æ—¶ç»“æœæ€»æ˜¯failureã€‚æ‰€ä»¥å¦‚æœåœ¨guardä¸ºå¤±è´¥çš„ç»“æœçš„æ—¶å€™ï¼Œæœ€ç»ˆçš„ç»“æœä¼šæ˜¯ä¸€ä¸ªç©ºæ•°ç»„ã€‚

```haskell
(>>) :: m a -> m b -> m b  
x >> y = x >>= \_ -> y
```

```
ghci> guard (5 > 2) >> return "cool" :: [String]  
["cool"]  
ghci> guard (1 > 2) >> return "cool" :: [String]  
[]
```

doçš„å†™æ³•ï¼š

```haskell
sevensOnly :: [Int]  
sevensOnly = do  
    x <- [1..50]  
    guard ('7' `elem` show x)  
    return x
```

#### Monad laws

monadåƒFunctoré‚£æ ·ä¹Ÿæœ‰è‡ªå·±çš„å®ä¾‹å¿…é¡»éµå®ˆçš„è§„åˆ™ã€‚å› ä¸ºå“ªä¸ªç©æ„åšäº†ä¸€ä¸ªMonadç±»å‹ç±»çš„ç´¢å¼•ï¼Œé‚£å¹¶ä¸æ„å‘³ç€ä»–å°±æ˜¯monadï¼Œé‚£åªä»£ç ä»–æ˜¯ç±»å‹ç±»çš„ä¸€ä¸ªå®ä¾‹ã€‚æ‰€æœ‰æ‰éœ€è¦è¿™äº›è§„åˆ™ï¼Œè¿™æ ·æ‰èƒ½è®©æˆ‘ä»¬æ¨æµ‹ç±»å‹å’Œä»–çš„è¡Œä¸ºã€‚haskellå…è®¸ä»»ä½•ç±»å‹æˆä¸ºmonadçš„å®ä¾‹ï¼Œä½†æ˜¯ä¸å¹¶ä¸ä¼šè‡ªåŠ¨å»æ£€æŸ¥æ˜¯å¦ç¬¦åˆè¯¥éµå®ˆçš„è¿™äº›è§„åˆ™ã€‚æ ‡å‡†åº“çš„éƒ½æ˜¯æ»¡è¶³æ¡ä»¶çš„ï¼Œè‡ªå·±è¦åšçš„è¯å°±å¾—æ‰‹åŠ¨æ£€æŸ¥ã€‚

**Left identity**

>  `return x >>= f`å’Œ`f x`æ˜¯ä¸€æ ·çš„ç»“æœ

```
ghci> return 3 >>= (\x -> Just (x+100000))  
Just 100003  
ghci> (\x -> Just (x+100000)) 3  
Just 100003
ghci> return "WoM" >>= (\x -> [x,x,x])  
["WoM","WoM","WoM"]  
ghci> (\x -> [x,x,x]) "WoM"  
["WoM","WoM","WoM"] 
```

**Right identity**

> `m >>= return` çš„ç»“æœå’Œ`m`ä¸€æ ·

è¿™ä¸ªä»å‡½æ•°ç±»å‹ä¸Šæ¥çœ‹ä¹Ÿå¥½ç†è§£ï¼Œmæ˜¯åŒ…å«ä¸Šä¸‹æ–‡çš„ï¼Œreturnæ˜¯æ¥å—çš„ä¸€ä¸ªå€¼ï¼Œç„¶åè¿”å›ä¸€ä¸ªåŒ…å«è¯¥å€¼çš„æœ€å°ä¸Šä¸‹æ–‡ï¼Œè¿™ä¸ªè¡¨è¾¾å¼å°±ç›¸å½“äºæŠŠmé‡Œçš„å€¼æ‹¿å‡ºæ¥ä¸¢è¿›returnï¼Œç„¶åreturnå†å¡å›å»ã€‚

```
ghci> Just "move on up" >>= (\x -> return x)  
Just "move on up"  
ghci> [1,2,3,4] >>= (\x -> return x)  
[1,2,3,4]  
ghci> putStrLn "Wah!" >>= (\x -> return x)  
Wah!
```

**Associativity**

å½“æœ‰ä¸€ä¸²monadicå‡½æ•°ç”¨`>>=`è¿æ¥çš„æ—¶å€™ï¼Œé‚£å°±ä¸åœ¨ä¹ä»–ä»¬å¦‚ä½•åµŒå¥—ï¼Œç»“æœéƒ½æ˜¯ä¸€æ ·çš„ï¼š

>  `(m >>= f) >>= g`çš„ç»“æœå’Œ`m >>= (\x -> f x >>= g)`çš„ç»“æœä¸€æ ·

è¿æ¥ä¸¤ä¸ªå‡½æ•°çš„æ˜¯è¿™æ ·å®šä¹‰çš„ï¼š

```haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)  
f . g = (\x -> f (g x))  
```

å¦‚æœè¿™é‡Œçš„å‡½æ•°éƒ½æ˜¯monadicï¼Œè€Œå‚æ•°éƒ½æ˜¯monadic valueå‘¢ï¼Ÿè¿™ä¸ªæ—¶å€™å°±å¯ä»¥ç”¨`<=<`ï¼š

```haskell
(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)  
f <=< g = (\x -> g x >>= f)  
```

```
ghci> let f x = [x,-x]  
ghci> let g x = [x*3,x*2]  
ghci> let h = f <=< g  
ghci> h 3  
[9,-9,6,-6]
```

é‚£ä¹ˆå¦‚æœç”¨åœ¨è¿™äº›è§„åˆ™ä¸Šï¼Œ`f <=< return`å’Œ`return <=< f`çš„ç»“æœæ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯`f`ã€‚

### For a Few Monads More

#### Writer? I hardly know her!

Writerè¿™ä¸ªmonadæ˜¯ä¸€ä¸ªç±»ä¼¼logçš„ä¸œè¥¿ï¼ŒWriterå…è®¸æˆ‘ä»¬è¿›è¡Œè®¡ç®—ï¼ŒåŒæ—¶ç¡®ä¿å°†æ‰€æœ‰æ—¥å¿—å€¼ç»„åˆä¸ºä¸€ä¸ªæ—¥å¿—å€¼ï¼Œç„¶åå°†å…¶é™„åŠ åˆ°ç»“æœä¸­ã€‚

```haskell
isBigGang x = x > 9  
isBigGang x = (x > 9, "Compared gang size to 9.")
```

ç¬¬äºŒä¸ªå‡½æ•°åœ¨è¿”å›æ¯”è¾ƒç»“æœçš„åŒæ—¶è¿˜ä¼´éšäº†ä¸€æ¡logï¼Œå³ç°åœ¨ç»“æœæ˜¯åŠ ä¸Šäº†ä¸Šä¸‹æ–‡çš„ç»“æœäº†ã€‚è¿™æ—¶å¦‚æœæˆ‘ä»¬å·²ç»æœ‰ä¸€ä¸ªå¸¦logçš„å€¼ï¼Œæƒ³è¦ä¸¢ç»™isBigGangè¿™ä¸ªå‡½æ•°è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿè¿™æ˜¯ä¸€ä¸ªç†Ÿæ‚‰çš„é—®é¢˜ï¼Œæ¢å¥è¯è¯´ï¼Œè¦æŠŠä¸€ä¸ªå¸¦ç›’å­çš„å€¼ï¼Œä¸¢ç»™ä¸€ä¸ªåªæ¥å—ä¸€ä¸ªæ™®é€šå€¼çš„å‡½æ•°ï¼Œè¯¥æ€ä¹ˆåŠã€‚

```haskell
applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)  
applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog) 
```

å¯ä»¥æ„å»ºä¸€ä¸ªä¸Šè¿°å‡½æ•°ï¼ŒæŠŠå€¼å–å‡ºæ¥æ‰§è¡Œå‡½æ•°çš„åŒæ—¶ï¼Œä¹Ÿä¸ä¸¢æ‰ä¹‹å‰çš„logä¿¡æ¯ã€‚

```
*Main> (3, "Smallish gang.") `applyLog` isBigGang
(False,"Smallish gang.Compared gang size to 9.")
```

applyLogçš„logç±»å‹ä¸€å®šå¾—æ˜¯Stringå—ï¼Ÿæ¯«æ— ç–‘é—®ï¼Œä¹Ÿå¯ä»¥æ˜¯Listï¼Œ`++`å‡½æ•°è¿˜å¯ä»¥æ²¿ç”¨ã€‚é‚£bytestringså‘¢ï¼Ÿé‚£æ˜¯ä¸æ˜¯å¾—åˆ†å¼€æ¥å†å†™ä¸€ä¸ªå¯¹åº”äºbytestringsçš„å‡½æ•°ï¼Ÿè¿™é‡Œçº ç»“çš„ç‚¹å…¶å®å°±æ˜¯`++`å‡½æ•°ï¼Œè€Œè€ƒè™‘åˆ°bytestringså’Œlistéƒ½æ˜¯monoidï¼Œé‚£ä¹ˆä»–ä»¬å°±éƒ½æœ‰mappendå‡½æ•°ï¼Œé‚£ä¹ˆæŠŠ`++`å‡½æ•°æ¢æˆmappendå‡½æ•°å°±èƒ½åº”ç”¨æ‰€æœ‰çš„monoidäº†å•¦ã€‚

```haskell
applyLog :: (Monoid m) => (a,m) -> (a -> (b,m)) -> (b,m)  
applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog) 
```

ç°åœ¨æˆ‘ä»¬ä¸ç”¨å†æŠŠè¿™ä¸ªtupleæƒ³è±¡æˆä¸€ä¸ªå€¼åŠ ä¸€æ¡logçš„ç»„åˆï¼Œå¯ä»¥æƒ³è±¡æˆä¸€ä¸ªå€¼åŠ ä¸Šä¸€ä¸ªä¼´éšç€çš„monoidå€¼ã€‚

```haskell
import Data.Monoid 

type Food = String
type Price = Sum Int

addDrink :: Food -> (Food, Price)
addDrink "beans" = ("milk", Sum 25)
addDrink "jerky" = ("whiskey", Sum 99)
addDrink _ = ("beer", Sum 30)
```

è¿™é‡Œçš„tupleç¬¬ä¸€ä¸ªå€¼è¡¨ç¤ºitemåï¼Œå¦ä¸€ä¸ªç”¨monoidæ¥è¡¨ç¤ºä»·æ ¼ã€‚å½“åƒbeansçš„æ—¶å€™å¹¶ä¸”è¦äº†é¥®æ–™çš„æ—¶å€™å°±æŠŠæ€»çš„ä»·æ ¼è¿”å›ã€‚

```haskell
*Main> ("beans", Sum 10) `applyLog` addDrink
("milk",Sum {getSum = 35})
```

#### writer

è¯´äº†è¿™ä¹ˆå¤šç»ˆäºåˆ°äº†ä¸»è§’Writeräº†ï¼Œå®šä¹‰å¾ˆç®€å•ï¼Œä¸ºäº†åœ¨å®ç°Monadçš„æ—¶å€™åŒºåˆ«äºæ™®é€šçš„tupleï¼Œè¿™é‡Œç”¨äº†newtypeé‡æ–°åŒ…è£¹äº†ä¸€ä¸‹ã€‚çœ‹è¿‡ä¹‹å‰çš„applyLogçš„å®ç°åï¼Œè¿™é‡Œçš„Monadå®ç°ä¹Ÿå¾ˆå¥½ç†è§£ã€‚

```haskell
newtype Writer w a = Writer { runWriter :: (a, w) } 

instance (Monoid w) => Monad (Writer w) where  
    return x = Writer (x, mempty)  
    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v') 
```

wè¢«é™åˆ¶ä¸ºä¸€ä¸ªMonoidï¼Œæ‰€ä»¥wæ˜¯å®ç°äº†memptyå’Œmappendå‡½æ•°çš„ï¼Œå›é¡¾ä¸‹memptyï¼Œè¡¨ç¤ºæœ€å°ä¸Šä¸‹æ–‡ï¼Œå½“aå’Œmemptyè¿›è¡Œmappendçš„æ—¶å€™ç»“æœä¸€å®šè¦æ˜¯aã€‚æ¯”å¦‚æ•°ç»„çš„memptyå°±æ˜¯ç©ºæ•°ç»„ã€‚

```
*Main Data.Monoid> mempty :: [a]
[]
*Main Data.Monoid> mempty :: String
""
```

æ‰€ä»¥å½“æ‰§è¡Œreturnçš„æ—¶å€™ä¼šæ ¹æ®é™å®šçš„ç±»å‹æ¥è¿”å›å¯¹åº”çš„å€¼ï¼š

```
Prelude Control.Monad.Writer> runWriter (return 3 :: Writer String Int)
(3,"")
Prelude Control.Monad.Writer> runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
```

#### Using do notation with Writer

```haskell
import Control.Monad.Writer  
  
logNumber :: Int -> Writer [String] Int
logNumber x = writer (x, ["Got number: " ++ show x])

multWithLog = do
  a <- logNumber 3
  b <- logNumber 5
  tell ["Gonna multiply these two"]
  return (a * b)
```

```
*Main Control.Monad.Writer> runWriter multWithLog
(15,["Got number: 3","Got number: 5","Gonna multiply these two"])
```

è¿™é‡Œç”¨åˆ°äº†tellï¼Œç”¨æ¥åœ¨ç‰¹å®šçš„åœ°æ–¹æŠŠæŸäº›monoidåŒ…å«è¿›å»ï¼Œè¦æ³¨æ„çš„æ—¶å€™ï¼Œè¿™é‡Œçš„tellçš„ç»“æœæ˜¯è¿”å›çš„()å¤–åŠ ä¸€ä¸ªmonoidï¼Œæ‰€ä»¥å¦‚æœtellæ”¾æœ€åçš„è¯ï¼Œé‚£ä¹ˆlogä¿¡æ¯è¿˜åœ¨ï¼Œä½†æ˜¯å› ä¸ºdoçš„æœ€åä¸€è¡Œæ˜¯æ•´æ®µä»£ç çš„ç»“æœï¼Œè€Œtellçš„ç»“æœæ˜¯()ï¼Œä¹Ÿå°±æ˜¯è¯´tellæ”¾æœ€åçš„è¯ï¼Œ`a*b`çš„ç»“æœå°±ä¸¢å¤±äº†ï¼Œåªæ˜¯logä¿¡æ¯è¿˜åœ¨è€Œå·²ã€‚

å› æ­¤tellåƒæ˜¯èƒ½å½“å…¶ä»–è¯­è¨€çš„printä¸€æ ·çš„æ¥åœ¨æ‰“æ—¥å¿—è°ƒè¯•ã€‚

