---
layout: post
title: ts
tags: [ts]
---

#### 接口

##### 对象接口：约束对象字段

```tsx
interface FullName{
    firstName:string;
    secondName?:string;  // 加上问号，表示可选参数
}
```

<!-- more -->

注意一个叫**额外属性的检查**的东西：

```tsx
function printName(name: FullName) {
  console.log(`${name.firstName} --- ${name.secondName}`);
}
```

像下面这样调用函数传参会报错，说多了一个team。

```ts
printName({
    firstName:'duncan',
    secondName:'tim',
    team:'spurs'
}) // error
```

但是如果将这个对象赋值给一个变量，再用这个变量作为参数传递就能跳过这种检查

```ts
var someone = {
  firstName: "duncan",
  secondName: "tim",
  team: "spurs"
};

printName(someone); // ok
```

也可以用as来跳过检查

```tsx
printName({
    firstName:'duncan',
    secondName:'tim',
    team:'spurs'
} as FullName)
```

##### 函数接口：约束函数参数和返回值

```ts
interface encrypt {
    (key:string, value:string):string
}

let en:encrypt = function (k:string, v:string):string{
    return k+v
}
```

##### 类接口：约束类属性和方法

```tsx
interface User1 {
  name: string; // 必须要有name属性，且为string类型
  sayHello(someword: string): void; // 必须要有sayHello方法
}

class RegularUser implements User1 {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
  sayHello(str: string) {
    console.log(`${this.name} says: ${str}`);
  }
}
```

##### 接口拓展

```tsx
interface PlayerUser extends User1 {
  team: string;
  play(): void;
}
```

#### 泛型

##### 泛型函数

定义：

```ts
function identity<T>(arg: T): T {
  return arg;
}
```

跟普通的函数定义多了个\<T\>，**可以看作是：之后（形参，函数体）都需要用T，所以得先声明T**。

使用：

```ts
let output = identity<string>("myString");
```

调用的时候，传入特定类型string来**锁定T类型**。

##### 泛型类型

那么泛型函数的类型也就多一个\<T\>

```ts
let myIdentity: <T>(arg: T) => T = identity;
```

或者这样写：

```ts
let myIdentity: {<T>(arg: T): T} = identity;
```

个人看法，这种写法有点像上面的函数接口写法。果然马上下面就开始讲泛型接口了。

##### 泛型接口

```ts
interface GenericIdentityFn {
    <T>(arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
```

泛型接口还有一种写法，把T当作接口的参数，这样整个接口内都能使用到T了，使用的时候传入具体类型：

```ts
interface GenericIdentityFn<T> {
    (arg: T): T;
}

let myIdentity: GenericIdentityFn<number> = identity;
```

##### 泛型类

和泛型接口类似，定义的时候后面多一个\<T\>

```ts
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
```

##### 泛型约束

因为泛型类型可以是任意类型，因此里面有哪些字段完全不确定，而当你确定T里面一定需要哪些字段的时候就需要对泛型类型进行约束了。如下例，谁也不能保证T里有length字段，因此报错。

```ts
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
```

定义一个接口来约束T，这样就保证了T中一定会有什么。

```ts
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
```

